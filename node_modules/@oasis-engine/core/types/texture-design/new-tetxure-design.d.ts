/**
 * 注意 RenderTarget colortxture 和 depthTexture 的格式兼容判断
 * RenderTarget 支持 Cube。
 */
import { EngineObject } from "../base/EngineObject";
import { Engine } from "../Engine";
/**
 * The base class of texture, contains some common functions of texture-related classes.
 */
export declare abstract class Texture {
    private name;
    /**
     * Wrapping mode for texture coordinate S.
     */
    get wrapModeU(): TextureWrapMode;
    set wrapModeU(value: TextureWrapMode);
    /**
     * Wrapping mode for texture coordinate T.
     */
    get wrapModeV(): TextureWrapMode;
    set wrapModeV(value: TextureWrapMode);
    /**
     * Texture mipmapping count.
     */
    get mipmapCount(): number;
    /**
     * Filter mode for texture.
     */
    get filterMode(): TextureFilterMode;
    set filterMode(value: TextureFilterMode);
    /**
     * Anisotropic level for texture.
     */
    get anisoLevel(): number;
    set anisoLevel(value: number);
    /**
     * Generate multi-level textures based on the 0th level data.
     */
    private generateMipmaps;
}
/**
 * Two-dimensional texture.
 */
export declare class Texture2D extends Texture {
    /**
     * The width of the texture.
     */
    get width(): number;
    /**
     * The height of the texture.
     */
    get height(): number;
    /**
     * Texture format.
     */
    get format(): TextureFormat;
    /**
     * Create Texture2D.
     * @param engine - Define the engine to use to render this texture
     * @param width - Texture width
     * @param height - Texture height
     * @param format - Texture format. default  `TextureFormat.R8G8B8A8`
     * @param mipmap - Whether to use multi-level texture
     */
    constructor(engine: Engine, width: number, height: number, format?: TextureFormat, mipmap?: boolean);
    /**
     * Setting pixels data through color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.
     * @remarks If it is the WebGL1.0 platform and the texture format is compressed, the first upload must be filled with textures.
     * @param colorBuffer - Color buffer data
     * @param mipLevel - Texture mipmapping level
     * @param x - X coordinate of area start
     * @param y - Y coordinate of area start
     * @param width - Data width. if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)
     * @param height - Data height. if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)
     */
    private setPixelBuffer;
    /**
     * Setting pixels data through TexImageSource, designated area and texture mipmapping level.
     * @param imageSource - The source of texture
     * @param mipLevel - Texture mipmapping level
     * @param flipY - Whether to flip the Y axis
     * @param premultiplyAlpha - Whether to premultiply the transparent channel
     * @param x - X coordinate of area start
     * @param y - Y coordinate of area start
     */
    private setImageSource;
    /**
     * Get pixel color buffer.
     * @param out - Color buffer
     */
    private getPixelBuffer;
}
/**
 * Cube texture.
 */
export declare class TextureCube extends Texture {
    /**
     * The size of the texture.
     */
    get size(): number;
    /**
     * Texture format.
     */
    get format(): TextureFormat;
    /**
     * Create TextureCube.
     * @param engine - Define the engine to use to render this texture
     * @param size - Texture size. texture width must be equal to height in cube texture
     * @param format - Texture format,default TextureFormat.R8G8B8A8
     * @param mipmap - Whether to use multi-level texture
     */
    constructor(engine: Engine, size: number, format?: TextureFormat, mipmap?: boolean);
    /**
     * Setting pixels data through cube face,color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.
     * @remarks When compressed texture is in WebGL1, the texture must be filled first before writing the sub-region
     * @param face - Cube face
     * @param colorBuffer - Color buffer data
     * @param mipLevel - Texture mipmapping level
     * @param x - X coordinate of area start
     * @param y -  Y coordinate of area start
     * @param width - Data width.if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)
     * @param height - Data height.if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)
     */
    private setPixelBuffer;
    /**
     * Setting pixels data through cube face, TexImageSource, designated area and texture mipmapping level.
     * @param face - Cube face
     * @param imageSource - The source of texture
     * @param mipLevel - Texture mipmapping level
     * @param flipY - Whether to flip the Y axis
     * @param premultiplyAlpha - Whether to premultiply the transparent channel
     * @param x - X coordinate of area start
     * @param y - Y coordinate of area start
     */
    private setImageSource;
    /**
     * Get pixel color buffer.
     * @param out - Color buffer
     */
    private getPixelBuffer;
}
/**
 * The render target used for off-screen rendering.
 */
export declare class RenderTarget extends EngineObject {
    /**
     * Render target width.
     */
    get width(): number;
    /**
     * Render target height.
     */
    get height(): number;
    /**
     * Render color texture count.
     */
    get colorTextureCount(): number;
    /**
     * Depth texture.
     */
    get depthTexture(): Texture | null;
    /**
     * Anti-aliasing level.
     * @remarks If the anti-aliasing level set is greater than the maximum level supported by the hardware, the maximum level of the hardware will be used.
     */
    get antiAliasing(): number;
    /**
     * Create a render target through color texture and depth format.
     * @param engine - Define the engine to use for this off-screen rendering
     * @param width - Render target width
     * @param height - Render target height
     * @param colorTexture - Render color texture
     * @param depthFormat - Depth format. default RenderBufferDepthFormat.Depth, engine will automatically select the supported precision
     * @param antiAliasing - Anti-aliasing level, default is 1
     */
    constructor(engine: Engine, width: number, height: number, colorTexture: Texture, depthFormat?: DepthBufferFormat | null, antiAliasing?: number);
    /**
     * Create a render target through color texture and depth format.
     * @remarks If the color texture is not transmitted, only the depth texture is generated.
     * @param engine - Define the engine to use for this off-screen rendering
     * @param width - Render target width
     * @param height - Render target height
     * @param colorTexture - Render color texture
     * @param depthTexture - Render depth texture
     * @param antiAliasing - Anti-aliasing level, default is 1
     */
    constructor(engine: Engine, width: number, height: number, colorTexture: Texture | null, depthTexture: Texture, antiAliasing?: number);
    /**
     * Create a render target with color texture array and depth format.
     * @param engine - Define the engine to use for this off-screen rendering
     * @param width - Render target width
     * @param height - Render target height
     * @param colorTextures - Render color texture array
     * @param depthFormat - Depth format. default RenderBufferDepthFormat.Depth,engine will automatically select the supported precision
     * @param antiAliasing - Anti-aliasing level, default is 1
     */
    constructor(engine: Engine, width: number, height: number, colorTextures: Texture[], depthFormat?: DepthBufferFormat | null, antiAliasing?: number);
    /**
     * Create a render target with color texture array and depth texture.
     * @param engine - Define the engine to use for this off-screen rendering
     * @param width - Render target width
     * @param height - Render target height
     * @param colorTextures - Render color texture array
     * @param depthTexture - Depth texture
     * @param antiAliasing - Anti-aliasing level, default is 1
     */
    constructor(engine: Engine, width: number, height: number, colorTextures: Texture[], depthTexture: Texture, antiAliasing?: number);
    /**
     *
     * Get the render color texture by index.
     * @param index
     */
    private getColorTexture;
    /**
     * Generate the mipmap of each attachment texture of the renderTarget according to the configuration.
     */
    private generateMipmaps;
    /**
     * Destroy render target.
     */
    private destroy;
}
/**
 * Depth texture format.
 */
export declare enum DepthBufferFormat {
    /** Render to depth buffer,engine will automatically select the supported precision. */
    Depth = 0,
    /** Render to depth stencil buffer, engine will automatically select the supported precision. */
    DepthStencil = 1,
    /** Render to stencil buffer. */
    Stencil = 2,
    /** Force 16-bit depth buffer. */
    Depth16 = 3,
    /** Force 24-bit depth buffer. */
    Depth24 = 4,
    /** Force 32-bit depth buffer. */
    Depth32 = 5,
    /** Force 16-bit depth + 8-bit stencil buffer. */
    Depth24Stencil8 = 6,
    /** Force 32-bit depth + 8-bit stencil buffer. */
    Depth32Stencil8 = 7
}
/**
 * Define the face of the cube texture.
 */
export declare enum TextureCubeFace {
    /** Positive X face for a cube-mapped texture. */
    PositiveX = 0,
    /** Negative X face for a cube-mapped texture. */
    NegativeX = 1,
    /** Positive Y face for a cube-mapped texture. */
    PositiveY = 2,
    /** Negative Y face for a cube-mapped texture. */
    NegativeY = 3,
    /** Positive Z face for a cube-mapped texture. */
    PositiveZ = 4,
    /** Negative Z face for a cube-mapped texture. */
    NegativeZ = 5
}
/**
 * The filter mode of the texture.
 */
export declare enum TextureFilterMode {
    /** Point filtering. */
    Point = 0,
    /** Bilinear filtering. */
    Bilinear = 1,
    /** Trilinear filtering. */
    Trilinear = 2
}
/**
 * Texture format enumeration.
 */
export declare enum TextureFormat {
    /** RGB format,8 bits per channel. */
    R8G8B8 = 0,
    /** RGBA format,8 bits per channel. */
    R8G8B8A8 = 1,
    /** RGBA format,4 bits per channel. */
    R4G4B4A4 = 2,
    /** RGBA format,5 bits in R channel,5 bits in G channel,5 bits in B channel, 1 bit in A channel. */
    R5G5B5A1 = 3,
    /** RGB format,5 bits in R channel,6 bits in G channel,5 bits in B channel. */
    R5G6B5 = 4,
    /** Transparent format,8 bits. */
    Alpha8 = 5,
    /** Luminance/alpha in RGB channel, alpha in A channel. */
    LuminanceAlpha = 6,
    /** RGBA format,16 bits per channel. */
    R16G16B16A16 = 7,
    /** RGBA format,32 bits per channel. */
    R32G32B32A32 = 7,
    /** RGB compressed format。*/
    DXT1 = 8,
    /** RGBA compressed format。*/
    DXT5 = 9,
    /** RGB compressed format,4 bits per pixel。*/
    ETC1_RGB = 10,
    /** RGB compressed format,4 bits per pixel。*/
    ETC2_RGB = 11,
    /** RGBA compressed format,5 bits per pixel,4 bit in RGB, 1 bit in A. */
    ETC2_RGBA5 = 12,
    /** RGB compressed format,8 bits per pixel. */
    ETC2_RGBA8 = 13,
    /** RGB compressed format,2 bits per pixel. */
    PVRTC_RGB2 = 14,
    /** RGBA compressed format,2 bits per pixel. */
    PVRTC_RGBA2 = 15,
    /** RGB compressed format,4 bits per pixel. */
    PVRTC_RGB4 = 16,
    /** RGBA compressed format,4 bits per pixel. */
    PVRTC_RGBA4 = 17,
    /** RGB(A) compressed format,128 bits per 4x4 pixel block. */
    ASTC_4x4 = 18,
    /** RGB(A) compressed format,128 bits per 5x5 pixel block. */
    ASTC_5x5 = 19,
    /** RGB(A) compressed format,128 bits per 6x6 pixel block. */
    ASTC_6x6 = 20,
    /** RGB(A) compressed format,128 bits per 8x8 pixel block. */
    ASTC_8x8 = 21,
    /** RGB(A) compressed format,128 bits per 10x10 pixel block. */
    ASTC_10x10 = 22,
    /** RGB(A) compressed format,128 bits per 12x12 pixel block. */
    ASTC_12x12 = 23,
    /** Render to depth buffer,engine will automatically select the supported precision. */
    Depth = 0,
    /** Render to depth stencil buffer, engine will automatically select the supported precision. */
    DepthStencil = 1,
    /** Render to stencil buffer. */
    Stencil = 2,
    /** Force 16-bit depth buffer. */
    Depth16 = 3,
    /** Force 24-bit depth buffer. */
    Depth24 = 4,
    /** Force 32-bit depth buffer. */
    Depth32 = 5,
    /** Force 16-bit depth + 8-bit stencil buffer. */
    Depth24Stencil8 = 6,
    /** Force 32-bit depth + 8-bit stencil buffer. */
    Depth32Stencil8 = 7
}
/**
 * Wrapping mode of the texture.
 */
export declare enum TextureWrapMode {
    /** Clamping mode. use the color of edge pixels beyond the texture boundary. */
    Clamp = 0,
    /** Repeating mode. tiling will be repeated if it exceeds the texture boundary. */
    Repeat = 1,
    /** Mirror repeat mode. tiling will be mirrored and repeated if it exceeds the texture boundary. */
    Mirror = 2
}
